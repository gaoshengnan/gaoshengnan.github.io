<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SEINA</title>
  
  <subtitle>SEINA BLOG</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://seina.top/"/>
  <updated>2018-11-16T10:04:20.064Z</updated>
  <id>http://seina.top/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微服务系统中故障种类及处理手段</title>
    <link href="http://seina.top/2018/11/16/faultHandling/"/>
    <id>http://seina.top/2018/11/16/faultHandling/</id>
    <published>2018-11-16T08:04:51.000Z</published>
    <updated>2018-11-16T10:04:20.064Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、常见三种故障："><a href="#一、常见三种故障：" class="headerlink" title="一、常见三种故障："></a>一、常见三种故障：</h3><blockquote><ul><li>单机故障：集群中的个别机器出现故障，导致调用到故障机器的请求都失败</li><li>集群故障：因为微服务系统一般都是集群部署的，根据业务量的大小而定，集群规模从几台到上万台都有可能。一旦某些代码出现bug可能整个集群都会发生故障，导致不能对外提供服务</li><li>单IDC故障：某个IDC的光缆因为道路施工被挖断，导致整个IDC脱网</li></ul></blockquote><h3 id="二、集群故障处理-—-限流和降级"><a href="#二、集群故障处理-—-限流和降级" class="headerlink" title="二、集群故障处理 — 限流和降级"></a>二、集群故障处理 — 限流和降级</h3><h5 id="产生的原因主要有两种"><a href="#产生的原因主要有两种" class="headerlink" title="产生的原因主要有两种"></a>产生的原因主要有两种</h5><blockquote><ol><li>代码bug所致，比如某一段Java代码不断地分配大对象，但没有及时回收导致JVM OOM退出</li><li>突发的流量冲击，超出了系统的最大承载能力，比如双11，零点一瞬间涌入大量流量</li></ol></blockquote><h5 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h5><p>限流就是指限制流量，在实际项目中可以使用QPS即每秒请求量和工作线程数这两个指标来衡量服务的请求量，不同服务的QPS响应的快慢不同，系统能够承载的QPS相差很大，因此一般选择工作线程数来作为限流的指标.给系统设置一个总的最大工作线程数以及单个服务的最大工作线程数，这样的话，无论系统的总请求量过大导致整体工作线程数量达到最大工作线程数，还是个别服务的请求量超过单个服务的最大工作线程数，都会被限流，以起到保护整个系统的作用。</p><p>系统能够承载的流量根据集群规模的大小是固定的，可以称之为整个系统的最大容量，当真实流量超过了系统的最大流量后，就会导致系统响应变慢，服务调用出现大量超时，反映给用户的感觉就是卡顿、无响应。</p><p>除此之外，通常一个微服务系统中会同时提供多个服务，每个服务在同一时刻的请求量也是不同，如果系统中某个服务的请求量突增，占用了系统中大部分资源，导致其他服务没有资源可用。</p><h5 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h5><blockquote><ol><li>根据系统的最大容量，给系统设置一个阈值，超过这个阈值的请求会自动抛弃，这样的化才可以最大限度地保证系统提供的服务正常。</li><li>针对系统中的每个服务的请求量也设置一个阈值，超过这个阈值的请求也要被自动放弃，这样也不至于一个服务影响了其他所有的服务</li></ol></blockquote><h5 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h5><p>降级就是通过停止系统中的某些功能，来保护系统的整体可用性，是一种被动防御的措施，一般是在系统出现故障后所采取的一种止损措施。比如我的笔记本同时接两个显示屏和电源，最近异常的很热，为了保证电脑不会热的爆炸，为了保证电脑的高可用性，我可以把电源降级，直接拔掉电源，或者拔掉一个显示屏等。</p><h6 id="降级的分类："><a href="#降级的分类：" class="headerlink" title="降级的分类："></a>降级的分类：</h6><blockquote><ul><li>一级降级：一级降级是对业务影响最小的降级，在故障的情况下，首先执行一级降级，所以一级降级也可以设置成自动降级，不需要人为干预</li><li>二级降级：二级降级是对业务有一定影响的降级，在故障的情况下，如果一级降级起不到多大作用的时候，可以人为采取措施，执行二级降级</li><li>三级降级：三级降级是对业务有较大影响的降级，这种降级要么是对商业收入有重大影响，要么是对用户体验有重大影响，所以操作起来要非常谨慎，不在最后时刻一般不予采用。</li></ul></blockquote><p>降级的一般通过开关来实现。具体来讲，在系统运行的内存中开辟出一块区域，专门用于存储开关的状态，并且需要监听某个端口，通过这个端口可以向系统下发命令，来改变内存中开关的状态。</p><h6 id="开关一般用在两种地方："><a href="#开关一般用在两种地方：" class="headerlink" title="开关一般用在两种地方："></a>开关一般用在两种地方：</h6><blockquote><ol><li>新增的业务逻辑：新增的业务逻辑相对来说不成熟，往往具备一定的风险，所以需要加开关来控制新业务逻辑是否执行</li><li>依赖的服务或资源：因为依赖的服务或者资源不总是可靠的，所以最好是有开关能够控制是否对依赖服务或资源发起调用，来保证即使依赖出现问题，也能通过降级来避免影响</li></ol></blockquote><h3 id="单IDC故障"><a href="#单IDC故障" class="headerlink" title="单IDC故障"></a>单IDC故障</h3><p>在现实情况下，整个IDC脱网的事情时有发生，比如机房着火、光缆被挖断等，如果业务全部部署在这个IDC，那就完全不可访问了。国内采取多IDC部署，当一个IDC发生故障之后，可以把原来访问故障 IDC 的流量切换到正常的 IDC，来保证业务的正常访问</p><blockquote><ul><li>同城双活：一个城市的两个 IDC 内部署</li><li>异地多活：一般是在两个城市的两个 IDC 内部署</li><li>三地五中心：支付宝这种金融级别的使用，成本显然高比两个 IDC 要高得多，但可用性的保障要更高</li></ul></blockquote><h6 id="那么流量怎么切换呢，一般分为两种："><a href="#那么流量怎么切换呢，一般分为两种：" class="headerlink" title="那么流量怎么切换呢，一般分为两种："></a>那么流量怎么切换呢，一般分为两种：</h6><ol><li><p>基于 DNS 解析的流量切换: 基于 DNS 解析流量的切换，一般是通过把请求访问域名解析的 VIP 从一个 IDC 切换到另外一个 IDC。比如访问<a href="www.weibo.com">www.weibo.com</a>， 正常情况下北方用户会解析到联通机房的 VIP，南方用户会解析到电信机房的 VIP，如果联通机房发生故障的话，会把北方用户访问也解析到电信机房的 VIP，只不过此时网络延迟可能会变长。</p></li><li><p>基于 RPC 分组的流量切换: 对于一个服务来说，如果是部署在多个 IDC 的话，一般每个 IDC 就是一个分组。假如一个 IDC 出现故障，那么原先路由到这个分组的流量，就可以通过向配置中心下发命令，把原先路由到这个分组的流量全部切换到别的分组，这样的话就可以切换故障IDC的流量。</p></li></ol><h3 id="三、单机故障"><a href="#三、单机故障" class="headerlink" title="三、单机故障"></a>三、单机故障</h3><p>在上万台机器的规模中出现单机故障是很常见的，这个时候只靠运维人肉处理显然不可行，所以就要求有某种手段来自动处理单机故障。</p><p>处理单机故障一个有效的办法就是自动重启。具体来讲，你可以设置一个阈值，比如以某个接口的平均耗时为准，当监控单机上某个接口的平均耗时超过一定阈值时，就认为这台机器有问题，这个时候就需要把有问题的机器从线上集群中摘除掉，然后在重启服务后，重新加入到集群中。</p><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><blockquote><ol><li>防止网络抖动造成的接口超时从而触发自动重：在收集单机接口耗时数据时，多采集几个点，比如每 10s 采集一个点，采集 5 个点，当 5 个点中有超过 3 个点的数据都超过设定的阈值范围，才认为是真正的单机问题，这时会触发自动重启策略。</li><li>短时间重启单机过多导致服务池可用节点太少：设置一个可重启的单机数量占整个集群的最大比例，一般这个比例不要超过 10%，因为正常情况下，不大可能有超过 10% 的单机都出现故障。</li></ol></blockquote><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>微服务可能出现的三种故障：集群故障，单机故障，单IDC故障，以及响应的解决方案：降级，限流，流量切换以及自动重启。在遇到实际故障时，往往多个手段是并用的，比如出现单IDC故障，首先要快速切换到正常的IDC，但此时可能正常的IDC并不足以支撑两个IDC的流量，所以要降级部分功能，保证正常的IDC顺利的支撑切换过来的流量。</p><p>而且尽量让故障处理自动化，这样可以大大减少故障影响的时间。因为一旦需要引入人为干预，往往故障处理的时间都得是10分钟以上，这对大部分用户敏感型业务的影响是巨大的，如果能做到自动化处理，可以将故障处理的时间降低到 1 分钟以内甚至秒级别，这样的话对于用户的影响最小。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、常见三种故障：&quot;&gt;&lt;a href=&quot;#一、常见三种故障：&quot; class=&quot;headerlink&quot; title=&quot;一、常见三种故障：&quot;&gt;&lt;/a&gt;一、常见三种故障：&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;单机故障：集群中的个别机器出现故障，导致调用到
      
    
    </summary>
    
      <category term="初识微服务" scheme="http://seina.top/categories/%E5%88%9D%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="微服务架构" scheme="http://seina.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"/>
    
      <category term="分布式系统" scheme="http://seina.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>如何快速的理解什么是微服务？</title>
    <link href="http://seina.top/2018/11/11/microservice/"/>
    <id>http://seina.top/2018/11/11/microservice/</id>
    <published>2018-11-11T14:48:37.000Z</published>
    <updated>2018-11-14T03:26:11.278Z</updated>
    
    <content type="html"><![CDATA[<h3 id="维基百科定义微服务"><a href="#维基百科定义微服务" class="headerlink" title="维基百科定义微服务"></a>维基百科定义微服务</h3><blockquote><p>维基百科定义微服务：微服务的概念最早实在2014年由MArtin Fowler和James Lewis共同提出，他们定义了微服务是由单一应用程序构成的小服务，拥有自己的进程和轻量化处理，服务依业务功能设计，以全自动的方式部署，与其他服务使用HTTP API通讯。同时。服务会使用最小规模的集中管理（如Docker）技术，服务可以用不同的编程语言和数据库等。</p></blockquote><p>好吧，可能看完了上面一段话反而觉得更难理解了，老外说的话一向都是这么生涩难懂，其实在我看来，要想深刻理解微服务的价值，需要先感受一下单体应用的痛苦！</p><h3 id="单体应用架构的不足"><a href="#单体应用架构的不足" class="headerlink" title="单体应用架构的不足"></a>单体应用架构的不足</h3><p>以MVC架构为例，业务通常通过部署一个WAR包到Tomcat中，然后启动Tomcat，监听某个端口号即可对外提供服务。早期在业务规模不大，开发团队人员规模较小的时候，采用单体应用架构，团队的开发和运维成本都可控，虽然偶尔也会解决一下冲突-.-。然而随着业务规模越来越大，代码越来越多，依赖的资源也很多，应用编译打包、部署测试一次，甚至需要10分钟以上，部署效率低下。</p><p>团队开发人员不断的扩张，彼此协作开发成本高，比如超过十个人协作修改代码，最后合并到master分支，一起打包部署，这样到了测试阶段只要有一块功能有问题，就得重新编译打包部署，然后重新预览测试，所有开发人员参与其中，效率超低。。</p><p>系统的高可用性差，一旦某个功能涉及的代码或者资源有问题，就会影响系统的可用性。比如某段代码不停的创建大对象，并且没有回收，运行一段时间后导致JVM内存泄漏，异常退出，那么部署在同一个JVM进程中的所有服务都不可用，后果很严重。。</p><h3 id="我理解的微服务"><a href="#我理解的微服务" class="headerlink" title="我理解的微服务"></a>我理解的微服务</h3><p>为了解决以上问题，服务化的思想诞生了。通俗来讲，服务化就是把传统的单体应用中通过JAR包依赖产生的本地方法调用，改造成RPC接口产生的远程方法调用。</p><p>我过去的项目经历里，比如项目包含用户模块，权限模块，应用模块等，其中权限模块需要调用用户模块取用户信息，应用模块也需要，所以把用户模块拆分出来，独立成一个服务部署，以RPC接口的形式对外提供服务，这样当权限模块调用用户服务的时候从进程内的调用变成远程RPC调用，这样，用户服务就可以独立开发部署测试上线和运维，可以交由专门的团队来做。</p><blockquote><p>什么时候进行服务化拆分：项目第一个阶段主要目标是快速开发和验证想法，证明产品思路是可行。这个阶段的功能设计一般不会太复杂，开发采取快速迭代的方式，架构设计也不适合过度。所有功能打包部署在一起开发测试运维，是最高效也是最节约成本的方式。当可行性验证通过，功能进一步迭代，就可以加入越来越多的新特性。</p></blockquote><blockquote><p>服务化拆分的两个姿势: </p><ol><li>纵向拆分，是从业务维度进行拆分，关联比较密切的拆分成一个微服务，而功能相对独立的业务员适合拆分成一个微服务</li><li>横向拆分，将公共且独立的功能模块拆分成一个微服务，即公共的被多个其他服务调用，且依赖的资源不与其他业务耦合</li></ol></blockquote><blockquote><p>小总结：服务化拆分粒度更细，服务独立部署，独立维护，服务治理要求能力高一些。拆分成微服务之后服务的数量变多，需要统一的服务治理平台，来对各个服务进行管理</p></blockquote><p>可见通过服务化，可以解决单体应用膨胀、团队开发耦合度高、协作效率低下的问题。在我看来，微服务发展到现在，已经不再单单局限于微服务架构本身，还与容器化、DevOps 等新的理念相结合，成为当前移动互联网时代最先进的业务架构解决方案，能更好地迎合移动互联网业务快速迭代的要求。</p><h3 id="服务化拆分必须要面临的问题"><a href="#服务化拆分必须要面临的问题" class="headerlink" title="服务化拆分必须要面临的问题"></a>服务化拆分必须要面临的问题</h3><ol><li><p>服务如何定义：对于微服务来说，每个服务都运行在各自的进程中，应该以接口的形式向外界传达自己的信息，无论采用哪种通讯协议，是HTTP还是RPC，服务之间的调用都通过接口描述来约定，约定包括接口名，接口参数以及接口的返回值</p></li><li><p>服务如何发布和订阅：服务调用者如何获取到需要调用服务的地址，这就需要一个注册中心</p></li><li><p>服务如何监控：通常对于一个服务，我们最关心的是 QPS（调用量）、AvgTime（平均耗时）以及 P999（99.9% 的请求性能在多少毫秒以内）这些指标。这时候你就需要一种通用的监控方案，能够覆盖业务埋点、数据收集、数据处理，最后到数据展示的全链路功能。</p></li><li><p>服务如何治理：可以想象，拆分为微服务架构后，服务的数量变多了，依赖关系也变复杂了。比如一个服务的性能有问题时，依赖的服务都势必会受到影响。可以设定一个调用性能阈值，如果一段时间内一直超过这个值，那么依赖服务的调用可以直接返回，这就是熔断，也是服务治理最常用的手段之一。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;维基百科定义微服务&quot;&gt;&lt;a href=&quot;#维基百科定义微服务&quot; class=&quot;headerlink&quot; title=&quot;维基百科定义微服务&quot;&gt;&lt;/a&gt;维基百科定义微服务&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;维基百科定义微服务：微服务的概念最早实在2014年由MAr
      
    
    </summary>
    
      <category term="初识微服务" scheme="http://seina.top/categories/%E5%88%9D%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="微服务架构" scheme="http://seina.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>ElasticSearch-关于映射类型的那些事</title>
    <link href="http://seina.top/2018/11/09/ELasticSearch/"/>
    <id>http://seina.top/2018/11/09/ELasticSearch/</id>
    <published>2018-11-09T03:33:44.000Z</published>
    <updated>2018-11-12T02:56:00.262Z</updated>
    
    <content type="html"><![CDATA[<h3 id="删除映射类型"><a href="#删除映射类型" class="headerlink" title="删除映射类型"></a>删除映射类型</h3><blockquote><p>在Elasticsearch 6.0.0 或者更高版本中创建的索引可能只包含单个映射类型，在5.x中创建的索引具有多种映射类型，这个功能将继续在6.x之前运行，映射类型将在7.0.0中完全删除。<br>（5.x-6.x:多种映射类型，6.x之后单个映射类型，7.0.0中映射类型完全消失）</p></blockquote><h3 id="什么是映射类型"><a href="#什么是映射类型" class="headerlink" title="什么是映射类型?"></a>什么是映射类型?</h3><p>自从Elasticsearch首个稳定版本发布以来，每个文档存储在单个索引里，并且分配映射类型，映射类型用来表示要编制索引的文档或者实体的类型，例如twitter索引可能具有user类型和tweet类型。</p><p>每个映射类型都有自己的字段，user类型也许有full_name字段，user_name字段，email字段，当然tweet也有content字段，tweeted_at字段和像user类型一样的user_name字段。</p><p>每个文档有一个_type元字段包含类型的名字，并且通过在URL指定类型名称s，可以将搜索限制为一种或多种类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET twitter/user,tweet/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span>: &#123;</span><br><span class="line">    <span class="string">"match"</span>: &#123;</span><br><span class="line">      <span class="string">"user_name"</span>: <span class="string">"kimchy"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个_type字段和文档的_id结合字段生成_uid字段，所以有相同_id字段的不同类型的文档可以存在同一个索引里。</p><p>映射类型也用在建立文档之间的亲子关系，就是question类型的文档可能和answer文档有亲子系。</p><h3 id="为什么映射类型会被删除？"><a href="#为什么映射类型会被删除？" class="headerlink" title="为什么映射类型会被删除？"></a>为什么映射类型会被删除？</h3><p>最初，我们谈到的索引类似SQL数据库中的数据库，类型相当于表。</p><p>这是一个很糟糕的比喻，导致了错误的假设，在SQL数据库里，表是彼此相互独立的，这个表中的列和另一个表中同样名字的列没有关系，映射类型中的字段不是这种情况。</p><p>在ElasticSearch索引中，在不同映射类型中有相同名字的字段在内部由相同的Lucene字段支持，换而言之，使用上面的例子，user类型中user_name字段被存储在与tweet类型的user_name字段名字相同的字段中，并且这两个不同类型的user_name字段必须有完全相同的映射。</p><p>当你想要删除一个类型的date字段和同一个索引中另一个类型的另一个boolean字段时，这可能会很令人绝望。</p><p>更重要的是，存储在同一个索引中具有很少或者没有共同字段的不同实体会导致稀疏数据并干扰Lucene有效压缩文档的能力。</p><p>综合这些原因，我们决定从ElasticSearch中删除映射类型的概念。</p><h3 id="映射类型的替代方法"><a href="#映射类型的替代方法" class="headerlink" title="映射类型的替代方法"></a>映射类型的替代方法</h3><h5 id="Index-per-document-type"><a href="#Index-per-document-type" class="headerlink" title="Index per document type"></a>Index per document type</h5><p>第一个替代方法是每个索引对应一个文档类型，不像原来将tweet和user存储在一个twitter索引中，你可以在tweets索引中存储tweets类型和在user索引中存储user类型，索引完全彼此相互独立，因此索引之间不会有字段冲突（比如上文描述的同一索引中不同类型的user_name）<br>这个方法有两个好处:</p><ol><li>数据更可能是密集的，并且有益于Lucene中使用压缩技术</li><li>用于全文搜索评分更可能是准确的，因为同一索引中的所有文档都代表单个实体。</li></ol><p>每个索引都可以适应文档的数量进行大小调整：您可以为user索引使用较少数量的主分片，为tweets索引使用较大的主分片。</p><h5 id="自定义类型字段"><a href="#自定义类型字段" class="headerlink" title="自定义类型字段"></a>自定义类型字段</h5><p>当然，集群中可以存在多少个主分片是有限制的，也许你并想要浪费整个主分片来存储几千个文档的集合，这种情况下，你可以实现你自己自定义的类型，工作方式和原来的_type一样。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;删除映射类型&quot;&gt;&lt;a href=&quot;#删除映射类型&quot; class=&quot;headerlink&quot; title=&quot;删除映射类型&quot;&gt;&lt;/a&gt;删除映射类型&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在Elasticsearch 6.0.0 或者更高版本中创建的索引可能只包含单个映
      
    
    </summary>
    
      <category term="ElasticSearch6.4官方文档翻译" scheme="http://seina.top/categories/ElasticSearch6-4%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="ElasticSearch" scheme="http://seina.top/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>常见设计原则-单一职责原则</title>
    <link href="http://seina.top/2018/11/05/singleResponsibility/"/>
    <id>http://seina.top/2018/11/05/singleResponsibility/</id>
    <published>2018-11-05T03:30:50.000Z</published>
    <updated>2018-11-14T08:45:57.452Z</updated>
    
    <content type="html"><![CDATA[<h3 id="小例子带你进入场景"><a href="#小例子带你进入场景" class="headerlink" title="小例子带你进入场景"></a>小例子带你进入场景</h3><p>例如我们日常生活中的手机，里面有摄像机、照片机、打电话、听音乐等多个功能，虽然手机小巧携带方便，但是显而易见，我们都知道手机的摄像功能没有摄像机拍摄的好，拍照功能没有照相机拍的好看。当然手机也只是过渡展品，如果摄像机，照相机像一张卡片那么大，又不失原有强大的拍照摄像功能，可能大家都不会用手机拍照了～</p><p>我们在编程的时候，自然而然的会给一个类增加各种各样的功能，比如我们写一个窗体应用程序，一般都会生成一个Forml这样的类，于是我们就会把各种各样的代码，像某种商业运算的算法呀，像数据库访问的SQL语句呀什么的都写到这样的类中，这就意味着，无论任何时候需求进来，你都需要更改这个窗体类，这其实是很糟糕的，维护麻烦，复用不可能，也缺乏灵活性。</p><p>再比如说我之前在高复用返回结果类ResultVO中加入JsonView时，这样一个类就具有了两个功能，后来我们老大说要把ResultVO统一拎出来管理，我那个服务的ResultVO打死也拎不动。。这就很尴尬了，可能当时一个类负责返回结果VO，另一个类负责JsonView展示，可能就会好很多。</p><h3 id="用最正确的姿势理解最简单的单一职责原则"><a href="#用最正确的姿势理解最简单的单一职责原则" class="headerlink" title="用最正确的姿势理解最简单的单一职责原则"></a>用最正确的姿势理解最简单的单一职责原则</h3><blockquote><p>单一职责原则：就一个类而言，应该仅有一个引起它变化的原因</p></blockquote><p>如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭到意想不到的破坏。</p><p>软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。其实要去判断是否应该分离出来也不是特别难，那就是如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责，就应该考虑类的职责分离。</p><blockquote><p>总结来说，在编程时，我们确实要在类的职责分离上多思考，做到单一职责，这样你的代码才是真正的易维护，易扩展，易复用，灵活多样。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;小例子带你进入场景&quot;&gt;&lt;a href=&quot;#小例子带你进入场景&quot; class=&quot;headerlink&quot; title=&quot;小例子带你进入场景&quot;&gt;&lt;/a&gt;小例子带你进入场景&lt;/h3&gt;&lt;p&gt;例如我们日常生活中的手机，里面有摄像机、照片机、打电话、听音乐等多个功能，虽然手机小
      
    
    </summary>
    
      <category term="大战设计模式" scheme="http://seina.top/categories/%E5%A4%A7%E6%88%98%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计原则" scheme="http://seina.top/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>常见设计原则-依赖倒置原则</title>
    <link href="http://seina.top/2018/11/04/dependencyInversion/"/>
    <id>http://seina.top/2018/11/04/dependencyInversion/</id>
    <published>2018-11-04T03:22:44.000Z</published>
    <updated>2018-11-14T07:04:24.734Z</updated>
    
    <content type="html"><![CDATA[<h3 id="加深依赖倒置原则定义的理解"><a href="#加深依赖倒置原则定义的理解" class="headerlink" title="加深依赖倒置原则定义的理解"></a>加深依赖倒置原则定义的理解</h3><blockquote><p>依赖倒置原则<br>A. 高层模块不应该依赖底层模块，两者都应该依赖其抽象<br>B. 抽象不应该依赖其细节，细节应该依赖抽象</p></blockquote><p>首先这不是小白级别的博客，只是我用来记录自己有关依赖倒置原则的理解，如果你一点都不了解依赖倒置原则，那么推荐一本大话设计模式～</p><p>好多人看完了依赖倒置原则都不理解，所谓的”倒置”，到底是在哪里，面向过程开发时，为了使得常用代码可以复用，一般都会把这些常用代码写成许许多多函数的程序库，这样我们在做新项目时，去调用这些底层的函数就可以的。比如我们做的项目大多数要访问数据库，所以我们就把访问数据库的代码写成了函数，每次做新项目的时候都要去调用这些函数，这就叫高层模块依赖底层模块。</p><p>这其实看起来并没有什么问题，业务逻辑的高层模块都是一样的，但客户希望使用不同的数据库或者存储信息方式，这时就麻烦了，我们希望再次利用这些高层模块，但是高层模块都是和底层模块绑在一起，没办法复用这些高层模块。例如PC电脑里如果CPU、内存、硬盘都需要依赖具体的主板，主板一坏，其他的部件就都没用了，反过来，如果内存坏了，也不应该造成其他部件不可用。</p><p>如果高层模块或者底层模块，它们都依赖于抽象，具体一点就是接口或者抽象类，只要接口是稳定的，那么任何一个改动都不用担心其他收到影响。</p><h3 id="通过coding进一步加深理解"><a href="#通过coding进一步加深理解" class="headerlink" title="通过coding进一步加深理解"></a>通过coding进一步加深理解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">课程接口</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICourse</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">studyCourse</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaCourse</span> <span class="keyword">implements</span> <span class="title">ICourse</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">studyCourse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Geely在学习Java课程"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Geely</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ICourse iCourse;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setiCourse</span><span class="params">(ICourse iCourse)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.iCourse = iCourse;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//给Geely一个学习课程的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">studyImoocCourse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        iCourse.studyCourse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 课程接口中有一个学习课程方法，有一个实现类重写了这个课程接口的方法</span></span><br><span class="line"><span class="comment">     * Geely有一个课程接口的属性，设置课程的方法，学习课程的方法（其中调用课程接口的学习课程的方法）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Geely geely = <span class="keyword">new</span> Geely();</span><br><span class="line">        <span class="comment">//给Geely设置哪个课程，他就会调用哪个课程的学习方法</span></span><br><span class="line">        geely.setiCourse(<span class="keyword">new</span> JavaCourse());</span><br><span class="line">        geely.studyImoocCourse();</span><br><span class="line"></span><br><span class="line">        geely.setiCourse(<span class="keyword">new</span> FECourse());</span><br><span class="line">        geely.studyImoocCourse();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，ICourse接口是固定不变，Test应用层应该没有依赖底层的Geely，而是Geely和Test都依赖其接口ICourse。</p><p>以上例子来源于<a href="https://coding.imooc.com/learn/list/270.html" target="_blank" rel="noopener">java设计模式精讲 Debug 方式+内存分析</a>，以及<a href="https://pan.baidu.com/s/1gyYmZiiRgxr85mwHz8UCGA" target="_blank" rel="noopener">大话设计模式pdf</a>–&gt;密码:ugu3</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;加深依赖倒置原则定义的理解&quot;&gt;&lt;a href=&quot;#加深依赖倒置原则定义的理解&quot; class=&quot;headerlink&quot; title=&quot;加深依赖倒置原则定义的理解&quot;&gt;&lt;/a&gt;加深依赖倒置原则定义的理解&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;依赖倒置原则&lt;br&gt;A. 
      
    
    </summary>
    
      <category term="大战设计模式" scheme="http://seina.top/categories/%E5%A4%A7%E6%88%98%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计原则" scheme="http://seina.top/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>常见设计原则-开闭原则</title>
    <link href="http://seina.top/2018/11/03/openClose/"/>
    <id>http://seina.top/2018/11/03/openClose/</id>
    <published>2018-11-03T03:31:38.000Z</published>
    <updated>2018-11-14T03:56:36.740Z</updated>
    
    <content type="html"><![CDATA[<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><blockquote><p>包括：开闭原则，依赖倒置原则，单一职责原则，接口隔离原则，最少知道原则(迪米特法则)，里氏替换原则，合成复用原则(组合复用原则)。<br>在实际开发过程中讲究一个平衡和取舍，要在适当的场景遵循设计原则，不要过度设计。</p></blockquote><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭，即可以扩展，不可以修改。用抽象构建框架，用实现扩展细节。<br>优点：提高软件系统的可复用性及可维护性<br>经典例子：一国两制，弹性8小时打卡</p><blockquote><p>核心思想：实现开闭原则的核心是面向抽象编程，而不是面向具体的实现编程</p></blockquote><p>我们在做任何系统的时候，都不要指定系统一开始的时候需求确定，就再也不会变化，这是不现实也不科学的想法，那么既然需求一定会变化，我们就应该重点关注怎么设计才能面对需求的改变却可以保持相对稳定。</p><p>越底层模块的变化影响的范围越大，越高层模块的变化影响的范围越小，简单理解，如果dao层被很多Service实现，如果改dao层，可能影响到其他模块的service，controller等。</p><p>如果接口里面有很多方法，实现类里面逻辑又很复杂，一旦改变了，风险很大，所以接口不应该经常变化，应该是稳定的，否则接口作为契约这个功能就失去了。既然抽象相对而言是稳定的，那么让类依赖于固定的抽象，就尽量不要修改原来稳定的代码，而通过面向对象的继承以及多态体的机制，就可以实现对抽象体的继承，通过重写改变其固有的方法，或者实现新的扩展方法，所以对扩展是开放对。</p><p>无论模块是多么封闭，都会存在一些无法对之封闭的变化。在我们最开始写代码的时候假设不会发生变化。当发生变化的时候，我们就立即采取行动，创建抽象来隔离以后发生的类似的变化。</p><blockquote><p>小总结：面对需求，我们对代码的改动是通过增加新代码进行的，而不是改动现有的代码。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;设计原则&quot;&gt;&lt;a href=&quot;#设计原则&quot; class=&quot;headerlink&quot; title=&quot;设计原则&quot;&gt;&lt;/a&gt;设计原则&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;包括：开闭原则，依赖倒置原则，单一职责原则，接口隔离原则，最少知道原则(迪米特法则)，里氏替换原则
      
    
    </summary>
    
      <category term="大战设计模式" scheme="http://seina.top/categories/%E5%A4%A7%E6%88%98%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计原则" scheme="http://seina.top/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>常见设计原则-组合复用原则</title>
    <link href="http://seina.top/2018/11/03/compositeReuse/"/>
    <id>http://seina.top/2018/11/03/compositeReuse/</id>
    <published>2018-11-03T01:28:37.000Z</published>
    <updated>2018-11-14T08:52:54.301Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="大战设计模式" scheme="http://seina.top/categories/%E5%A4%A7%E6%88%98%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计原则" scheme="http://seina.top/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>常见设计原则-里氏替换原则</title>
    <link href="http://seina.top/2018/11/02/ridleyReplace/"/>
    <id>http://seina.top/2018/11/02/ridleyReplace/</id>
    <published>2018-11-02T03:28:42.000Z</published>
    <updated>2018-11-14T14:35:17.146Z</updated>
    
    <content type="html"><![CDATA[<p>里氏替换原则：子类型必须能够替换掉它们的父类型。</p><blockquote><p>含义1：子类可以实现父类的抽象方法，但是不可以覆盖父类的非抽象方法<br>含义2：子类中可以增加自己特有的方法<br>含义3：当子类的方法重写父类的方法时，方法的前置条件(即方法的输入/输出)要比父类方法的输入参数更宽松<br>含义4：当子类的方法实现父类的方法时(重写/重载/实现抽象方法)，方法的后置条件(即方法的输出/返回值)要比父类更严格或者相等</p></blockquote><p>一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类和子类对象的区别，也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化，简单地说，子类型必须能够替换掉它们的父类型。</p><p>如果面向对象设计时，一个是鸟类，一个是企鹅类，如果鸟是可以飞的，企鹅不会飞，那么企鹅是鸟吗？企鹅可以继承鸟这个类吗？显然是不可以的，子类拥有父类所有非private的行为和属性。鸟会飞，而企鹅不会飞。尽管在生物学分类上，企鹅是一种鸟，但在编程世界里，企鹅不能以父类–鸟的身份出现，因为前提是说所有鸟都能飞，企鹅不能飞，所以企鹅不能继承鸟类。</p><p>也正是因为有了里氏替换原则，使得继承复用成为可能，只有当子类可以替换掉父类，软件单位的功能不受影响时，父类才能真正地被复用，而子类也能够在父类的基础上增加新的行为。比如说猫是继承动物类的，以动物的身份拥有吃、喝、跑、叫等行为，可当某一天，我们需要狗、牛、羊也拥有类似的行为，由于它们都是继承动物，所以更改实例化的地方，程序其他处都不需要改变。需要变化的是猫更换成狗、牛、羊等别的动物，程序其他地方不需要改变。</p><blockquote><p>正是由于子类型的可替换性才使得使用父类类型的模块在无需修改的情况下就可以扩展</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;里氏替换原则：子类型必须能够替换掉它们的父类型。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;含义1：子类可以实现父类的抽象方法，但是不可以覆盖父类的非抽象方法&lt;br&gt;含义2：子类中可以增加自己特有的方法&lt;br&gt;含义3：当子类的方法重写父类的方法时，方法的前置条件(即方法的输入
      
    
    </summary>
    
      <category term="大战设计模式" scheme="http://seina.top/categories/%E5%A4%A7%E6%88%98%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计原则" scheme="http://seina.top/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
</feed>
