{"meta":{"title":"SEINA","subtitle":"SEINA BLOG","description":"个人博客，主要记录笔者在程序媛道路上的技术成长和思想沉淀，也会涉及一些开源技术官方文档翻译～由于博客刚刚搭建几天，评论等个别功能尚未集成，敬请谅解，笔者有时间一定会尽快完善～","author":"John Doe","url":"http://seina.top"},"pages":[{"title":"404 Page Not Found","date":"2017-08-04T15:36:59.000Z","updated":"2018-11-08T17:06:18.484Z","comments":true,"path":"404.html","permalink":"http://seina.top/404.html","excerpt":"","text":""},{"title":"404 Page Not Found","date":"2017-08-04T15:36:59.000Z","updated":"2018-11-08T08:15:56.058Z","comments":true,"path":"index.html","permalink":"http://seina.top/index.html","excerpt":"","text":""},{"title":"search","date":"2018-11-08T08:14:36.000Z","updated":"2018-11-08T08:14:59.123Z","comments":true,"path":"search/index.html","permalink":"http://seina.top/search/index.html","excerpt":"","text":""},{"title":"about","date":"2018-11-08T08:13:39.000Z","updated":"2019-01-02T13:15:35.368Z","comments":true,"path":"about/index.html","permalink":"http://seina.top/about/index.html","excerpt":"","text":"关与笔者高胜男，又名笙南，现任职于上海DaoCloud微服务开发工程师，主要研究方向是微服务架构落地方案、DevOps持续集成交付、容器编排等。 不喜欢知其然而不知其所以然的流氓工程师，虽然只有不满一年编程经验，但始终在钻研技术原理的道路上前行 座右铭命运给你一个比别人低的起点是想告诉你，让你用你的一生去奋斗出一个绝地反击的故事。这个故事关于独立、关于梦想、关于勇气、关于坚忍，它不是一个水到渠成的童话，没有一点点人间疾苦，这个故事是有志者事竟成，破釜沉舟，百二秦关终属楚，这个故事是苦心人天不负，卧薪尝胆，三千越甲可吞吴! 关于博客 博客迁移：原来在csdn博客上面写文章，上面的文章并没有全部挪动过来，实在很忙-.-好奇的直接点过去看哈～ 一直以来都想有一个自己的博客，本博客网站基于Hexo的主题进行二次整改，感谢原博主的主题，尊重原创，尊重版权。整改后的博客欢迎大家Star，有问题可以提问，我看到之后会在第一时间回复，也可以扫描最下面二维码加我微信讨论～ 由于平时工作以及各项学习任务缠身，博客暂时还有评论功能，访问统计量，友情链接模块等功能，搜索功能也暂时不够强大，后续都会慢慢实现和优化哒～ 关于编程底层基础决定上层建筑，想要成为一名优秀的程序员，建议注重个人基础学习，比如计算机网络基础，23中常见设计模式，数据结构和算法等leetCode什么的刷起来。。。从现在开始吧，不留余力地努力吧，最差的结果，也不过是大器晚成。为什么强调程序员要学习算法和设计模式，第一点，可以写出性能更优的代码，不至于自己嫌弃自己的代码，全等着CodeReview～第二点，大脑思考能力是个人最重要的核心竞争力，而算法是为数不多的能够有效训练大脑思考能力的途径之一"}],"posts":[{"title":"Exception 和 Error 有什么区别？","slug":"ExceptionAndError","date":"2019-06-30T23:01:28.000Z","updated":"2019-07-01T09:56:39.988Z","comments":true,"path":"2019/07/01/ExceptionAndError/","link":"","permalink":"http://seina.top/2019/07/01/ExceptionAndError/","excerpt":"","text":"问题一：对比 Exception 和 Error ？Exception 和 Error 都是继承了 Throwable 类。 Exception 是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应处理。 Error 是指在正常情况下，不大可能出现的情况，绝大部分的 Error 都会导致程序（比如 JVM 自身）处于非正常的、不可恢复状态，是程序本身无法修复的错误，常见的比如 OutOfMemoryError 之类，都是 Error 的子类。 问题二：运行时异常和一般异常有什么区别 ？Exception 又分为可检查异常（checked）和不检查异常（unchecked）。 可检查异常在源代码里必须显式地进行捕获处理，这是编译期检查的一部分。 不可检查异常就是所谓的运行时异常，类似 NullPointerException、ArrayIndexOutOfBoundsException 之类，通常是可以编码避免的逻辑错误，具体根据需要来判断是否需要捕获，并不会在编译期强制要求。 问题三：你了解那些 Error、Exception 或者 RuntimeException ？Error： VirtualMachineError、OutOfMemoryError、StackOverflowError Exception： IOException 等检查异常 RuntimeException 运行时异常：NullPointerException、ArrayIndexOutOfBoundsException","categories":[{"name":"Java 核心基础","slug":"Java-核心基础","permalink":"http://seina.top/categories/Java-核心基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://seina.top/tags/Java/"}],"keywords":[{"name":"Java 核心基础","slug":"Java-核心基础","permalink":"http://seina.top/categories/Java-核心基础/"}]},{"title":"K个一组翻转链表","slug":"reverseNodesInKGroup","date":"2019-01-21T15:29:52.000Z","updated":"2019-01-22T02:54:28.552Z","comments":true,"path":"2019/01/21/reverseNodesInKGroup/","link":"","permalink":"http://seina.top/2019/01/21/reverseNodesInKGroup/","excerpt":"","text":"英文版：https://leetcode.com/problems/reverse-nodes-in-k-group/ 中文版：https://leetcode-cn.com/problems/reverse-nodes-in-k-group/ 题意：首先，我们以7个结点的链表为例，假设K等于3，那么反转前后链表如下图所示： 第一轮K个结点反转 注：以下所有思路，请参考上面ReverseNodesInkGroup.java里给出的推荐答案进行阅读。还有head = pre == null ? cur : head，为了不扰乱整理逻辑，这句话暂时先不管，是用来标识时刻变化的链表的第一个结点，以便最后返回。 首先看到推荐答案中代码有点多，没关系，可以先什么都不管，第一轮K个结点反转只要从cur=head入手，然后进入while循环，然后看下图观察cur随count的变化： 可以看出count从1到3，cur从结点1走到结点3，然后进入if条件语句。开始给start赋值，首先pre是null，所以start表示从head开始，随后给left，start，end，right赋值，赋值之后如下图所示： 进入resign方法，分别用p，c，n指针来反转K个结点，此处和反转单链表思路类似，K个结点反转过程如下图： 由图可以看出当n等于right的时候停止反转，并将结点1（反转后的尾结点）和结点4（下一组K个结点的首结点）连上。随后将pre指向第一个K组结点反转后的尾结点（也就是下一组K结点的前一个结点），并将cur指向下一组K结点的首结点，以上一轮大的while循环结束。如下图可见指针情况： 第二轮K个结点反转进入第二轮K个结点反转，cur随着count++从结点4移动到结点6，如下图所示： 然后继续调用resign方法，给left，start，end，right赋值，如下图所示： 进入resign方法，开始反转第二组K个结点，需要注意的是，此时left不为null，要将上一组K个结点和这一组K个结点连上，如下图： 最后调整指针如下图： 然后当count=2时，不满足条件，退出循环，返回head。","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://seina.top/categories/数据结构和算法/"}],"tags":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://seina.top/tags/数据结构和算法/"},{"name":"链表","slug":"链表","permalink":"http://seina.top/tags/链表/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://seina.top/tags/LeetCode/"}],"keywords":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://seina.top/categories/数据结构和算法/"}]},{"title":"Activiti6.0.0工作流引擎的web程序设计器","slug":"activitiWebBpmn","date":"2019-01-18T03:36:01.000Z","updated":"2019-01-18T07:38:09.507Z","comments":true,"path":"2019/01/18/activitiWebBpmn/","link":"","permalink":"http://seina.top/2019/01/18/activitiWebBpmn/","excerpt":"","text":"一、流程设计器环境搭建步骤 首先在Activiti官网下载activiti6.0.0 然后下载Tomcat8.0.53 最后把activiti-6.0.0/wars/activiti-admin.war 和 activiti-6.0.0/wars/activiti-app.war放到tomcat的webapp目录下 二、Activiti6.0.0-bpmn20-webActiviti6.0.0-bpmn20-web是我搭建好的Web流程设计器环境，可以直接clone项目到本地启动，就可以在线设计工作流引擎流程图 git clone https://github.com/gaoshengnan/Activiti6.0.0-bpmn20-web.git 拉下代码之后打开Terminal，启动Tomcat 访问http://localhost:8080/activiti-admin，用户名 username：admin | 密码 password：admin 这里默认的Server port是9999，修改端口号为8080，设置app的密码为test 并点击【Check Activiti Rest endpoint】测试一下 然后访问http://localhost:8080/activiti-app，用户名 username：admin | 密码 password：test 现在可以开始设计流程图了～～～ 默认h2数据库改成mysql数据库activiti默认配置h2的数据库，当重新启动Tomcat，设计好的流程图就被清空，可以配置成自己的mysql数据库，修改这个路径下的配置： apache-tomcat-8.0.53/webapps/activiti-app/WEB-INF/classes/META-INF/activiti-app/activiti-app.properties 注意：切换时如果出现问题可以查看这片故障排查记录记录ActivitiWeb流程设计器从h2转成mysql线上故障排查","categories":[{"name":"Activiti工作流","slug":"Activiti工作流","permalink":"http://seina.top/categories/Activiti工作流/"}],"tags":[{"name":"Activiti","slug":"Activiti","permalink":"http://seina.top/tags/Activiti/"}],"keywords":[{"name":"Activiti工作流","slug":"Activiti工作流","permalink":"http://seina.top/categories/Activiti工作流/"}]},{"title":"记录ActivitiWeb流程设计器从h2转成mysql线上故障排查","slug":"activitiWebH2ToMysql","date":"2019-01-17T12:56:16.000Z","updated":"2019-01-17T15:23:16.189Z","comments":true,"path":"2019/01/17/activitiWebH2ToMysql/","link":"","permalink":"http://seina.top/2019/01/17/activitiWebH2ToMysql/","excerpt":"","text":"故障场景描述首先我要做的事情是用自己集成好的Activiti在线web流程设计器画工作流流程图，但是限于Activiti默认配置是h2数据库，在Tomcat重新重启之后，画好的流程配置文件数据就没了。于是准备换成mysql的数据库，便可以将流程配置文件持久落库。 实际上我集成好的流程设计器是将Activiti6.0.0的war包activiti-app和activiti-admin放在Tomcat的webapps下，然后启动tomcat，访问http://localhost:8080/activiti-app 登录之后开始设计工作流流程图。 对应操作修改activiti-app的数据库，配置文件对应路径如下：Activiti6.0.0-bpmn20-web/apache-tomcat-8.0.53/webapps/activiti-app/WEB-INF/classes/META-INF/activiti-app/activiti-app.properties 原来的h2数据库配置 改成mysql配置 看似简单的操作，在我改好之后，重新启动Tomcat，访问http://localhost:8080/activiti-app 发现报错404，明显activiti-app没有成功部署到服务器上。 开始排查问题接下来查看服务器的logs/catalina.out日志，发现异常信息： 原来activiti-app在tomcat启动的时候，会创建一个表，其中表的字段如图中蓝色框框里的ID_VARCHAR（255）指定为PRIMARY_KEY(ID_)主键，导致mysql报错：Index column size too large. The maximum column size is 767 bytes，意思是索引字段太长，限制长度为767个字节。 然后一脸懵逼的把这个异常信息粘到百度，发现mysql5.6版本有重要的Innodb参数innodb_large_prefix全局动态变量，在5.6中默认是关闭的（5.7默认开启），该参数表示Innodb为字段创建索引时，限制的字节长度，关闭时，字节长度大于767则会报warnings，开启时则会报错，创建不成功. 解决问题然后查看了一下数据库mysql的字符集编码： show variables like ‘character_set_database’; 发现是utf8mb4，mysql从5.5.3之后增加了utfmb4的编码，专门用来兼容4字节的unicode，好在utf8mb4是utf8的超集，除了将编码改为utf8mb4外不需要做其他转换。而在utf8中，中文一般占3个字节。所以上面的ID_主键索引设置成255，如果是utfmb4，大约1020，超过了767个字节，所以换成是utf8，问题就解决了 alter database activiti character set utf8; 最后重新启动Tomcat服务，就可以访问activiti-app页面开始设计流程图了～～","categories":[{"name":"Activiti工作流","slug":"Activiti工作流","permalink":"http://seina.top/categories/Activiti工作流/"}],"tags":[{"name":"Activiti","slug":"Activiti","permalink":"http://seina.top/tags/Activiti/"},{"name":"Mysql","slug":"Mysql","permalink":"http://seina.top/tags/Mysql/"}],"keywords":[{"name":"Activiti工作流","slug":"Activiti工作流","permalink":"http://seina.top/categories/Activiti工作流/"}]},{"title":"链表 - 判断一个链表是否有环以及求出环入口点","slug":"linkedListCycle","date":"2019-01-14T15:18:00.000Z","updated":"2019-01-15T13:03:01.596Z","comments":true,"path":"2019/01/14/linkedListCycle/","link":"","permalink":"http://seina.top/2019/01/14/linkedListCycle/","excerpt":"","text":"一、LeetCode141 英文版：https://leetcode.com/problems/linked-list-cycle/ 中文版：https://leetcode-cn.com/problems/linked-list-cycle/ 答案链接：https://github.com/gaoshengnan/LeetCode/blob/master/src/main/java/linkedlist/linkedListCycle/LinkedListCycle.java 二、题意解析：1、首先如果一个单链表没有环，最后一个结点指向null，如下图1所示： 2、但是如果一个链表有环，以下是我能想到有环的三种情况，如下图2所示： 三、简单描述前两种解法第一种，从上图1和图2可以看出，有环和无环的区别是最后一个结点是否指向null，如果指向null，表示无环，如果没有指向null，则有环 第二种，循环遍历链表，每经过一个结点，将结点的next指针存入Set集合，如果发现有重复的，则有环，否则无环 四、详细讲解最后一种解法第三种，使用快慢指针来解答，快指针每次循环走两步，慢指针每次循环走一步，如果链表无环，像图1一样，是一条直线，快指针和慢指针同时出发，快指针又比慢指针走的快两倍，那慢指针和快指针永远都不会相遇但是像图2，链表中有环，意味着快指针走着走着，会拐弯，进入环里，就意味着有机会和慢指针相遇。 有环链表-示例1图2中第一个简单的有环链表，蓝色圆圈fast代表快指针，红色小心心low代表慢指针，如图3所示： 第1步，fast和low从A结点同时出发，fast每次走两个结点，low每次走一个结点 第2步，fast经过A-B-C，走到C；low经过A-B，走到B 第3步，fast经过C-A-B，走到B；low经过B-C，走到C然后fast继续经过B-C-A，low继续经过C-A，所以两个指针在A结点相遇，其中fast指针的路线A-B-C-A-B-C-A，low指针的路线A-B-C-A。 有环链表-示例2看图2中的第二个有环的链表，如下图4所示：(此处不再详细画出) 由上图4可以看出，fast指针在E结点处拐弯，两次经过E结点拐弯，最终在I结点和low相遇。 有环链表-示例3图2中第三个有环的链表，如下图5所示： 五、扩展LeetCode142 英文版：https://leetcode.com/problems/linked-list-cycle-ii/ 中文版：https://leetcode-cn.com/problems/linked-list-cycle-ii/ 题意解析：如果链表有环，返回该环的入口结点，如下图所示： 上面图中fast指针的low指针同时从A结点出发，fast每次走两步，low每次走一步，在G结点相遇，发现链表有环，不难观察出fast和low的路线如下图： 然后假设起始结点A到环入口点C的距离是x，入口点C到相遇点的距离是y，相遇点到入口点的距离是z，所以得出以下结论： 所以解题思路是当发现快指针fast和慢指针low相遇之后，让fast指针从起始结点出发，再次相遇的点就是环的入口点。 答案链接：https://github.com/gaoshengnan/LeetCode/blob/master/src/main/java/linkedlist/linkedListCycle/LinkedListCycle.java","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://seina.top/categories/数据结构和算法/"}],"tags":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://seina.top/tags/数据结构和算法/"},{"name":"链表","slug":"链表","permalink":"http://seina.top/tags/链表/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://seina.top/tags/LeetCode/"}],"keywords":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://seina.top/categories/数据结构和算法/"}]},{"title":"极客时间海报礼券分享","slug":"geekTime","date":"2019-01-02T11:58:35.000Z","updated":"2019-01-17T13:04:07.763Z","comments":true,"path":"2019/01/02/geekTime/","link":"","permalink":"http://seina.top/2019/01/02/geekTime/","excerpt":"","text":"扫描我分享的课程专栏海报二维码，在买专栏的时候就能获取立减券，金额不定～ 一、10x程序员工作法优秀程序员的开发效率是普通程序员的10倍。 二、技术管理实战36讲当你学会用“带团队”的思路工作和生活之后，无论你是否拥有”管理者”的头衔，你都将成为身边人事实上的领袖。 三、从0开始学微服务微服务是当下最火热的后端架构之一。不管你是一个什么级别的程序员，服务化都是你迟早会遇到的难题。 四、趣谈网络协议网络协议是每个程序员的必修课，但是彻底掌握并应用网络协议知识却并非易事，比如常见的HTTP、TCP/IP。 五、Java核心技术36讲将基础很重要，现如今不需要那些”差不多”或者”还行”的代码，而是需要达到一定水准的高质量设计与实现。 六、深入拆解Java虚拟机Oracle高级研究员来解答你对Java的种种疑虑，达到知其然也要知其所以然。 七、数据结构和算法之美一个让你能真正受用的数据结构和算法课程，希望给你指明一个简洁、高效的学习路径，并教你一个学习基础知识的通用方法。 八、算法面试通关40讲前Facebook工程师带你刷算法题，覃超老师的课程真的超级超级棒，老师很帅，满满的干货带你挑战算法。 最后，加入极客时间专栏学习已经有一段时间，从早上洗漱，化妆到上班地铁上，以及从手机里面的网易云音乐切换到到极客时间专栏课程，利用琐碎时间充实自己，感觉收获颇多。","categories":[{"name":"极客时间学习","slug":"极客时间学习","permalink":"http://seina.top/categories/极客时间学习/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://seina.top/tags/Java/"},{"name":"极客时间","slug":"极客时间","permalink":"http://seina.top/tags/极客时间/"},{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://seina.top/tags/数据结构和算法/"},{"name":"网络协议","slug":"网络协议","permalink":"http://seina.top/tags/网络协议/"},{"name":"Jvm","slug":"Jvm","permalink":"http://seina.top/tags/Jvm/"},{"name":"微服务架构","slug":"微服务架构","permalink":"http://seina.top/tags/微服务架构/"}],"keywords":[{"name":"极客时间学习","slug":"极客时间学习","permalink":"http://seina.top/categories/极客时间学习/"}]},{"title":"简而易懂的代理模式","slug":"proxy","date":"2018-11-26T13:39:25.000Z","updated":"2018-11-26T15:05:45.884Z","comments":true,"path":"2018/11/26/proxy/","link":"","permalink":"http://seina.top/2018/11/26/proxy/","excerpt":"","text":"故事场景有一个小仙女叫seina，他有一个追求者叫pursuit，和她的好朋友daili，pursuit准备了chocolate和doll，请daili代送给seina，此刻注意，seina并不认识pursuit。 错误代码1 — 没有代理的代码呃…为什么要写错误的代码，因为只有从错误过渡到正确的艰辛过程，才会知道正确的重要性 首先有个小仙女，构造器注入她的名字12345678910111213141516/*** Fairy:小仙女seina*/public class Fairy &#123; private String name; public Fairy(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125;&#125; 然后有一个追求者，有个属性是小仙女，构造器注入小仙女，表示追求哪个小仙女的追求者，以及给哪个小仙女送巧克力和洋娃娃12345678910111213141516171819/*** Pursuit:追求者*/public class Pursuit &#123; Fairy mm = null; Pursuit(Fairy mm) &#123; this.mm = mm; &#125; void giveDolls()&#123; System.out.println(\"送\"+mm.getName()+\"洋娃娃\"); &#125; void giveChocolate()&#123; System.out.println(\"送\"+mm.getName()+\"巧克力\"); &#125;&#125; 代理类Proxy和追求者功能类似12345678910111213141516171819/*** Proxy:代理类*/public class Proxy &#123; Fairy mm = null; Proxy(Fairy mm) &#123; this.mm = mm; &#125; void giveDolls()&#123; System.out.println(\"送\"+mm.getName()+\"洋娃娃\"); &#125; void giveChocolate()&#123; System.out.println(\"送\"+mm.getName()+\"巧克力\"); &#125;&#125; 客户端调用代码如下：1234567891011121314151617181920212223public class Client &#123; public static void main(String[] args) &#123; Fairy seina = new Fairy(\"seina\"); /** * 不使用代理 * seina并不认识这个追求者，所以此段不符合实际 */ Pursuit pursuit = new Pursuit(seina); pursuit.giveChocolate(); pursuit.giveDolls(); /** * 使用代理 * 把追求者换成代理类daili，也不合理，因为礼物是追求者准备的... */ Proxy daili = new Proxy(seina); daili.giveChocolate(); daili.giveDolls(); &#125;&#125; 写到这里，我们来想一下，不使用代理的时候，seina并不认识pursuit，直接让pursuit送礼物不太合理。当有了代理类的时候，让代理类来送礼物，却把真正准备礼物的pursuit给弄丢了…仔细观察，Pursuit和Proxy都有送礼的方法，只不过Proxy送的礼物是Pursuit准备的，实质上也是Pursuit送的，嗯，这才合理。 符合实际的代码将送礼物提取成一个接口，包含送礼物方法:123456789/*** IGiveGif:送礼物接口*/public interface IGiveGift &#123; void giveDolls(); void giveChocolate();&#125; 然后让追求者去实现送礼物接口，可以理解成追求者是那个具体准备礼物的人12345678910111213141516171819202122/*** Pursuit:追求者*/public class Pursuit implements IGiveGift &#123; Fairy mm = null; //声明一个追求某个学妹的追求者 public Pursuit(Fairy mm) &#123; this.mm = mm; &#125; @Override public void giveDolls() &#123; System.out.println(\"送\"+mm.getName()+\"洋娃娃\"); &#125; @Override public void giveChocolate() &#123; System.out.println(\"送\"+mm.getName()+\"巧克力\"); &#125;&#125; 代理类也实现送礼物接口，在代理中构造追求者，并调用追求者送礼物的方法1234567891011121314151617181920212223/*** Proxy:代理类*/public class Proxy implements IGiveGift &#123; Pursuit pursuit = null; //在代理的构造器里也构造了一个追求者，为了让他去准备礼物-，-哈哈哈 public Proxy(Fairy mm) &#123; pursuit = new Pursuit(mm); &#125; @Override public void giveDolls() &#123; //在实现中调用追求者的方式，实质上代理只是帮忙代送礼物，真正准备礼物的还是追求者 pursuit.giveDolls(); &#125; @Override public void giveChocolate() &#123; pursuit.giveChocolate(); &#125;&#125; 客户端调用代码如下：12345678910111213public class Client &#123; public static void main(String[] args) &#123; Fairy seina = new Fairy(\"seina\"); Proxy daili = new Proxy(seina); daili.giveChocolate(); daili.giveDolls(); &#125;&#125; 事实上，seina不认识他的追求者，但却可以通过代理得到追求者的礼物，可能收到礼物的时候，如果代理不告诉他是谁准备的礼物，seina也不知道到底是谁送给她的 官方这样讲代理模式 代理模式(Proxy): 为对象提供一种代理以控制对这个对象的访问。 代理模式的应用场合一般分为以下几种： 远程代理：也就是为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实。例如，客户端程序调用代理解决远程访问的问题。 虚拟代理：是根据需要创建开销很大的对象。通过它来存放实例化很长时间的真实对象，这样就可以达到性能的最优化，比如打开HTML网页时，里面可能有很大的图片的文字，但是还可以很快打开，此时看到的是一张一张下载后才能看到，那些未打开的图片框，就是使用虚拟代理来替代了真实的图片，此时代理存储了真实的图片的路径和尺寸。 安全代理：用来控制真实对象访问时的权限，一般用于对象有不同权限的时候。 智能指引：是指当调用真实对象的时候，代理处理另外一些事情。如计算真实对象的引用次数，这样当该对象没有引用时，可以自动释放它，或当第一次引用一个持久对象时，将它装入内存，或在访问一个实际对象前，检查是否已经锁定它，以确保其他对象不能改变它，它们都是通过代理在访问一个对象时附加一些内务处理。 代理模式其实就是在访问对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途 还有查看其他设计模式请移步github：https://github.com/gaoshengnan/designPattern 注：代码风格有点丑，这片先这样吧，等我找到怎么修改这个黑暗的背景再来把它改掉。。。","categories":[{"name":"大战设计模式","slug":"大战设计模式","permalink":"http://seina.top/categories/大战设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://seina.top/tags/设计模式/"}],"keywords":[{"name":"大战设计模式","slug":"大战设计模式","permalink":"http://seina.top/categories/大战设计模式/"}]},{"title":"微服务系统中故障种类及处理手段","slug":"faultHandling","date":"2018-11-16T08:04:51.000Z","updated":"2018-11-16T10:04:20.064Z","comments":true,"path":"2018/11/16/faultHandling/","link":"","permalink":"http://seina.top/2018/11/16/faultHandling/","excerpt":"","text":"一、常见三种故障： 单机故障：集群中的个别机器出现故障，导致调用到故障机器的请求都失败 集群故障：因为微服务系统一般都是集群部署的，根据业务量的大小而定，集群规模从几台到上万台都有可能。一旦某些代码出现bug可能整个集群都会发生故障，导致不能对外提供服务 单IDC故障：某个IDC的光缆因为道路施工被挖断，导致整个IDC脱网 二、集群故障处理 — 限流和降级产生的原因主要有两种 代码bug所致，比如某一段Java代码不断地分配大对象，但没有及时回收导致JVM OOM退出 突发的流量冲击，超出了系统的最大承载能力，比如双11，零点一瞬间涌入大量流量 限流限流就是指限制流量，在实际项目中可以使用QPS即每秒请求量和工作线程数这两个指标来衡量服务的请求量，不同服务的QPS响应的快慢不同，系统能够承载的QPS相差很大，因此一般选择工作线程数来作为限流的指标.给系统设置一个总的最大工作线程数以及单个服务的最大工作线程数，这样的话，无论系统的总请求量过大导致整体工作线程数量达到最大工作线程数，还是个别服务的请求量超过单个服务的最大工作线程数，都会被限流，以起到保护整个系统的作用。 系统能够承载的流量根据集群规模的大小是固定的，可以称之为整个系统的最大容量，当真实流量超过了系统的最大流量后，就会导致系统响应变慢，服务调用出现大量超时，反映给用户的感觉就是卡顿、无响应。 除此之外，通常一个微服务系统中会同时提供多个服务，每个服务在同一时刻的请求量也是不同，如果系统中某个服务的请求量突增，占用了系统中大部分资源，导致其他服务没有资源可用。 解决办法： 根据系统的最大容量，给系统设置一个阈值，超过这个阈值的请求会自动抛弃，这样的化才可以最大限度地保证系统提供的服务正常。 针对系统中的每个服务的请求量也设置一个阈值，超过这个阈值的请求也要被自动放弃，这样也不至于一个服务影响了其他所有的服务 降级降级就是通过停止系统中的某些功能，来保护系统的整体可用性，是一种被动防御的措施，一般是在系统出现故障后所采取的一种止损措施。比如我的笔记本同时接两个显示屏和电源，最近异常的很热，为了保证电脑不会热的爆炸，为了保证电脑的高可用性，我可以把电源降级，直接拔掉电源，或者拔掉一个显示屏等。 降级的分类： 一级降级：一级降级是对业务影响最小的降级，在故障的情况下，首先执行一级降级，所以一级降级也可以设置成自动降级，不需要人为干预 二级降级：二级降级是对业务有一定影响的降级，在故障的情况下，如果一级降级起不到多大作用的时候，可以人为采取措施，执行二级降级 三级降级：三级降级是对业务有较大影响的降级，这种降级要么是对商业收入有重大影响，要么是对用户体验有重大影响，所以操作起来要非常谨慎，不在最后时刻一般不予采用。 降级的一般通过开关来实现。具体来讲，在系统运行的内存中开辟出一块区域，专门用于存储开关的状态，并且需要监听某个端口，通过这个端口可以向系统下发命令，来改变内存中开关的状态。 开关一般用在两种地方： 新增的业务逻辑：新增的业务逻辑相对来说不成熟，往往具备一定的风险，所以需要加开关来控制新业务逻辑是否执行 依赖的服务或资源：因为依赖的服务或者资源不总是可靠的，所以最好是有开关能够控制是否对依赖服务或资源发起调用，来保证即使依赖出现问题，也能通过降级来避免影响 单IDC故障在现实情况下，整个IDC脱网的事情时有发生，比如机房着火、光缆被挖断等，如果业务全部部署在这个IDC，那就完全不可访问了。国内采取多IDC部署，当一个IDC发生故障之后，可以把原来访问故障 IDC 的流量切换到正常的 IDC，来保证业务的正常访问 同城双活：一个城市的两个 IDC 内部署 异地多活：一般是在两个城市的两个 IDC 内部署 三地五中心：支付宝这种金融级别的使用，成本显然高比两个 IDC 要高得多，但可用性的保障要更高 那么流量怎么切换呢，一般分为两种： 基于 DNS 解析的流量切换: 基于 DNS 解析流量的切换，一般是通过把请求访问域名解析的 VIP 从一个 IDC 切换到另外一个 IDC。比如访问www.weibo.com， 正常情况下北方用户会解析到联通机房的 VIP，南方用户会解析到电信机房的 VIP，如果联通机房发生故障的话，会把北方用户访问也解析到电信机房的 VIP，只不过此时网络延迟可能会变长。 基于 RPC 分组的流量切换: 对于一个服务来说，如果是部署在多个 IDC 的话，一般每个 IDC 就是一个分组。假如一个 IDC 出现故障，那么原先路由到这个分组的流量，就可以通过向配置中心下发命令，把原先路由到这个分组的流量全部切换到别的分组，这样的话就可以切换故障IDC的流量。 三、单机故障在上万台机器的规模中出现单机故障是很常见的，这个时候只靠运维人肉处理显然不可行，所以就要求有某种手段来自动处理单机故障。 处理单机故障一个有效的办法就是自动重启。具体来讲，你可以设置一个阈值，比如以某个接口的平均耗时为准，当监控单机上某个接口的平均耗时超过一定阈值时，就认为这台机器有问题，这个时候就需要把有问题的机器从线上集群中摘除掉，然后在重启服务后，重新加入到集群中。 注意： 防止网络抖动造成的接口超时从而触发自动重：在收集单机接口耗时数据时，多采集几个点，比如每 10s 采集一个点，采集 5 个点，当 5 个点中有超过 3 个点的数据都超过设定的阈值范围，才认为是真正的单机问题，这时会触发自动重启策略。 短时间重启单机过多导致服务池可用节点太少：设置一个可重启的单机数量占整个集群的最大比例，一般这个比例不要超过 10%，因为正常情况下，不大可能有超过 10% 的单机都出现故障。 四、总结微服务可能出现的三种故障：集群故障，单机故障，单IDC故障，以及响应的解决方案：降级，限流，流量切换以及自动重启。在遇到实际故障时，往往多个手段是并用的，比如出现单IDC故障，首先要快速切换到正常的IDC，但此时可能正常的IDC并不足以支撑两个IDC的流量，所以要降级部分功能，保证正常的IDC顺利的支撑切换过来的流量。 而且尽量让故障处理自动化，这样可以大大减少故障影响的时间。因为一旦需要引入人为干预，往往故障处理的时间都得是10分钟以上，这对大部分用户敏感型业务的影响是巨大的，如果能做到自动化处理，可以将故障处理的时间降低到 1 分钟以内甚至秒级别，这样的话对于用户的影响最小。","categories":[{"name":"初识微服务","slug":"初识微服务","permalink":"http://seina.top/categories/初识微服务/"}],"tags":[{"name":"微服务架构","slug":"微服务架构","permalink":"http://seina.top/tags/微服务架构/"},{"name":"分布式系统","slug":"分布式系统","permalink":"http://seina.top/tags/分布式系统/"}],"keywords":[{"name":"初识微服务","slug":"初识微服务","permalink":"http://seina.top/categories/初识微服务/"}]},{"title":"如何快速的理解什么是微服务？","slug":"microservice","date":"2018-11-11T14:48:37.000Z","updated":"2019-07-01T07:42:20.325Z","comments":true,"path":"2018/11/11/microservice/","link":"","permalink":"http://seina.top/2018/11/11/microservice/","excerpt":"","text":"维基百科定义微服务 维基百科定义微服务：微服务的概念最早实在 2014 年由 Martin Fowler 和 James Lewis 共同提出，他们定义了微服务是由单一应用程序构成的小服务，拥有自己的进程和轻量化处理，服务依业务功能设计，以全自动的方式部署，与其他服务使用 HTTP API 通讯。同时。服务会使用最小规模的集中管理（如 Docker）技术，服务可以用不同的编程语言和数据库等。 好吧，可能看完了上面一段话反而觉得更难理解了，老外说的话一向都是这么生涩难懂，其实在我看来，要想深刻理解微服务的价值，需要先感受一下单体应用的痛苦！ 单体应用架构的不足以 MVC 架构为例，业务通常通过部署一个 WAR 包到 Tomcat 中，然后启动 Tomcat，监听某个端口号即可对外提供服务。早期在业务规模不大，开发团队人员规模较小的时候，采用单体应用架构，团队的开发和运维成本都可控，虽然偶尔也会解决一下冲突 -.-。然而随着业务规模越来越大，代码越来越多，依赖的资源也很多，应用编译打包、部署测试一次，甚至需要 10 分钟以上，部署效率低下。 团队开发人员不断的扩张，彼此协作开发成本高，比如超过十个人协作修改代码，最后合并到 master 分支，一起打包部署，这样到了测试阶段只要有一块功能有问题，就得重新编译打包部署，然后重新预览测试，所有开发人员参与其中，效率超低。。 系统的高可用性差，一旦某个功能涉及的代码或者资源有问题，就会影响系统的可用性。比如某段代码不停的创建大对象，并且没有回收，运行一段时间后导致 JVM 内存泄漏，异常退出，那么部署在同一个 JVM 进程中的所有服务都不可用，后果很严重。。 我理解的微服务为了解决以上问题，服务化的思想诞生了。通俗来讲，服务化就是把传统的单体应用中通过 JAR 包依赖产生的本地方法调用，改造成 RPC 接口产生的远程方法调用。 我过去的项目经历里，比如项目包含用户模块，权限模块，应用模块等，其中权限模块需要调用用户模块取用户信息，应用模块也需要，所以把用户模块拆分出来，独立成一个服务部署，以 RPC 接口的形式对外提供服务，这样当权限模块调用用户服务的时候从进程内的调用变成远程 RPC 调用，这样，用户服务就可以独立开发部署测试上线和运维，可以交由专门的团队来做。 什么时候进行服务化拆分：项目第一个阶段主要目标是快速开发和验证想法，证明产品思路是可行。这个阶段的功能设计一般不会太复杂，开发采取快速迭代的方式，架构设计也不适合过度。所有功能打包部署在一起开发测试运维，是最高效也是最节约成本的方式。当可行性验证通过，功能进一步迭代，就可以加入越来越多的新特性。 服务化拆分的两个姿势: 纵向拆分，是从业务维度进行拆分，关联比较密切的拆分成一个微服务，而功能相对独立的业务员适合拆分成一个微服务 横向拆分，将公共且独立的功能模块拆分成一个微服务，即公共的被多个其他服务调用，且依赖的资源不与其他业务耦合 小总结：服务化拆分粒度更细，服务独立部署，独立维护，服务治理要求能力高一些。拆分成微服务之后服务的数量变多，需要统一的服务治理平台，来对各个服务进行管理 可见通过服务化，可以解决单体应用膨胀、团队开发耦合度高、协作效率低下的问题。在我看来，微服务发展到现在，已经不再单单局限于微服务架构本身，还与容器化、DevOps 等新的理念相结合，成为当前移动互联网时代最先进的业务架构解决方案，能更好地迎合移动互联网业务快速迭代的要求。 服务化拆分必须要面临的问题 服务如何定义：对于微服务来说，每个服务都运行在各自的进程中，应该以接口的形式向外界传达自己的信息，无论采用哪种通讯协议，是 HTTP 还是 RPC，服务之间的调用都通过接口描述来约定，约定包括接口名，接口参数以及接口的返回值 服务如何发布和订阅：服务调用者如何获取到需要调用服务的地址，这就需要一个注册中心 服务如何监控：通常对于一个服务，我们最关心的是 QPS（调用量）、AvgTime（平均耗时）以及 P999（99.9% 的请求性能在多少毫秒以内）这些指标。这时候你就需要一种通用的监控方案，能够覆盖业务埋点、数据收集、数据处理，最后到数据展示的全链路功能。 服务如何治理：可以想象，拆分为微服务架构后，服务的数量变多了，依赖关系也变复杂了。比如一个服务的性能有问题时，依赖的服务都势必会受到影响。可以设定一个调用性能阈值，如果一段时间内一直超过这个值，那么依赖服务的调用可以直接返回，这就是熔断，也是服务治理最常用的手段之一。","categories":[{"name":"初识微服务","slug":"初识微服务","permalink":"http://seina.top/categories/初识微服务/"}],"tags":[{"name":"微服务架构","slug":"微服务架构","permalink":"http://seina.top/tags/微服务架构/"}],"keywords":[{"name":"初识微服务","slug":"初识微服务","permalink":"http://seina.top/categories/初识微服务/"}]},{"title":"常见设计原则-单一职责原则","slug":"singleResponsibility","date":"2018-11-05T03:30:50.000Z","updated":"2018-11-14T08:45:57.452Z","comments":true,"path":"2018/11/05/singleResponsibility/","link":"","permalink":"http://seina.top/2018/11/05/singleResponsibility/","excerpt":"","text":"小例子带你进入场景例如我们日常生活中的手机，里面有摄像机、照片机、打电话、听音乐等多个功能，虽然手机小巧携带方便，但是显而易见，我们都知道手机的摄像功能没有摄像机拍摄的好，拍照功能没有照相机拍的好看。当然手机也只是过渡展品，如果摄像机，照相机像一张卡片那么大，又不失原有强大的拍照摄像功能，可能大家都不会用手机拍照了～ 我们在编程的时候，自然而然的会给一个类增加各种各样的功能，比如我们写一个窗体应用程序，一般都会生成一个Forml这样的类，于是我们就会把各种各样的代码，像某种商业运算的算法呀，像数据库访问的SQL语句呀什么的都写到这样的类中，这就意味着，无论任何时候需求进来，你都需要更改这个窗体类，这其实是很糟糕的，维护麻烦，复用不可能，也缺乏灵活性。 再比如说我之前在高复用返回结果类ResultVO中加入JsonView时，这样一个类就具有了两个功能，后来我们老大说要把ResultVO统一拎出来管理，我那个服务的ResultVO打死也拎不动。。这就很尴尬了，可能当时一个类负责返回结果VO，另一个类负责JsonView展示，可能就会好很多。 用最正确的姿势理解最简单的单一职责原则 单一职责原则：就一个类而言，应该仅有一个引起它变化的原因 如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭到意想不到的破坏。 软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。其实要去判断是否应该分离出来也不是特别难，那就是如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责，就应该考虑类的职责分离。 总结来说，在编程时，我们确实要在类的职责分离上多思考，做到单一职责，这样你的代码才是真正的易维护，易扩展，易复用，灵活多样。","categories":[{"name":"大战设计模式","slug":"大战设计模式","permalink":"http://seina.top/categories/大战设计模式/"}],"tags":[{"name":"设计原则","slug":"设计原则","permalink":"http://seina.top/tags/设计原则/"}],"keywords":[{"name":"大战设计模式","slug":"大战设计模式","permalink":"http://seina.top/categories/大战设计模式/"}]},{"title":"常见设计原则-依赖倒置原则","slug":"dependencyInversion","date":"2018-11-04T03:22:44.000Z","updated":"2018-11-14T07:04:24.734Z","comments":true,"path":"2018/11/04/dependencyInversion/","link":"","permalink":"http://seina.top/2018/11/04/dependencyInversion/","excerpt":"","text":"加深依赖倒置原则定义的理解 依赖倒置原则A. 高层模块不应该依赖底层模块，两者都应该依赖其抽象B. 抽象不应该依赖其细节，细节应该依赖抽象 首先这不是小白级别的博客，只是我用来记录自己有关依赖倒置原则的理解，如果你一点都不了解依赖倒置原则，那么推荐一本大话设计模式～ 好多人看完了依赖倒置原则都不理解，所谓的”倒置”，到底是在哪里，面向过程开发时，为了使得常用代码可以复用，一般都会把这些常用代码写成许许多多函数的程序库，这样我们在做新项目时，去调用这些底层的函数就可以的。比如我们做的项目大多数要访问数据库，所以我们就把访问数据库的代码写成了函数，每次做新项目的时候都要去调用这些函数，这就叫高层模块依赖底层模块。 这其实看起来并没有什么问题，业务逻辑的高层模块都是一样的，但客户希望使用不同的数据库或者存储信息方式，这时就麻烦了，我们希望再次利用这些高层模块，但是高层模块都是和底层模块绑在一起，没办法复用这些高层模块。例如PC电脑里如果CPU、内存、硬盘都需要依赖具体的主板，主板一坏，其他的部件就都没用了，反过来，如果内存坏了，也不应该造成其他部件不可用。 如果高层模块或者底层模块，它们都依赖于抽象，具体一点就是接口或者抽象类，只要接口是稳定的，那么任何一个改动都不用担心其他收到影响。 通过coding进一步加深理解1234课程接口public interface ICourse &#123; void studyCourse();&#125; 123456public class JavaCourse implements ICourse &#123; @Override public void studyCourse() &#123; System.out.println(\"Geely在学习Java课程\"); &#125;&#125; 12345678910public class Geely &#123; private ICourse iCourse; public void setiCourse(ICourse iCourse) &#123; this.iCourse = iCourse; &#125; //给Geely一个学习课程的方法 public void studyImoocCourse()&#123; iCourse.studyCourse(); &#125;&#125; 123456789101112131415public class Test &#123;/** * 课程接口中有一个学习课程方法，有一个实现类重写了这个课程接口的方法 * Geely有一个课程接口的属性，设置课程的方法，学习课程的方法（其中调用课程接口的学习课程的方法） * @param args */ public static void main(String[] args) &#123; Geely geely = new Geely(); //给Geely设置哪个课程，他就会调用哪个课程的学习方法 geely.setiCourse(new JavaCourse()); geely.studyImoocCourse(); geely.setiCourse(new FECourse()); geely.studyImoocCourse();&#125; 上述代码中，ICourse接口是固定不变，Test应用层应该没有依赖底层的Geely，而是Geely和Test都依赖其接口ICourse。 以上例子来源于java设计模式精讲 Debug 方式+内存分析，以及大话设计模式pdf–&gt;密码:ugu3","categories":[{"name":"大战设计模式","slug":"大战设计模式","permalink":"http://seina.top/categories/大战设计模式/"}],"tags":[{"name":"设计原则","slug":"设计原则","permalink":"http://seina.top/tags/设计原则/"}],"keywords":[{"name":"大战设计模式","slug":"大战设计模式","permalink":"http://seina.top/categories/大战设计模式/"}]},{"title":"常见设计原则-开闭原则","slug":"openClose","date":"2018-11-03T03:31:38.000Z","updated":"2018-11-26T13:50:18.121Z","comments":true,"path":"2018/11/03/openClose/","link":"","permalink":"http://seina.top/2018/11/03/openClose/","excerpt":"","text":"设计原则 包括：开闭原则，依赖倒置原则，单一职责原则，接口隔离原则，最少知道原则(迪米特法则)，里氏替换原则，合成复用原则(组合复用原则)。在实际开发过程中讲究一个平衡和取舍，要在适当的场景遵循设计原则，不要过度设计。 开闭原则定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭，即可以扩展，不可以修改。用抽象构建框架，用实现扩展细节。优点：提高软件系统的可复用性及可维护性经典例子：一国两制，弹性8小时打卡 核心思想：实现开闭原则的核心是面向抽象编程，而不是面向具体的实现编程 我们在做任何系统的时候，都不要指定系统一开始的时候需求确定，就再也不会变化，这是不现实也不科学的想法，那么既然需求一定会变化，我们就应该重点关注怎么设计才能面对需求的改变却可以保持相对稳定。 越底层模块的变化影响的范围越大，越高层模块的变化影响的范围越小，简单理解，如果dao层被很多Service实现，如果改dao层，可能影响到其他模块的service，controller等。 如果接口里面有很多方法，实现类里面逻辑又很复杂，一旦改变了，风险很大，所以接口不应该经常变化，应该是稳定的，否则接口作为契约这个功能就失去了。既然抽象相对而言是稳定的，那么让类依赖于固定的抽象，就尽量不要修改原来稳定的代码，而通过面向对象的继承以及多态体的机制，就可以实现对抽象体的继承，通过重写改变其固有的方法，或者实现新的扩展方法，所以对扩展是开放对。 无论模块是多么封闭，都会存在一些无法对之封闭的变化。在我们最开始写代码的时候假设不会发生变化。当发生变化的时候，我们就立即采取行动，创建抽象来隔离以后发生的类似的变化。 小总结：面对需求，我们对代码的改动是通过增加新代码进行的，而不是改动现有的代码。","categories":[{"name":"大战设计模式","slug":"大战设计模式","permalink":"http://seina.top/categories/大战设计模式/"}],"tags":[{"name":"设计原则","slug":"设计原则","permalink":"http://seina.top/tags/设计原则/"}],"keywords":[{"name":"大战设计模式","slug":"大战设计模式","permalink":"http://seina.top/categories/大战设计模式/"}]},{"title":"常见设计原则-组合复用原则","slug":"compositeReuse","date":"2018-11-03T01:28:37.000Z","updated":"2018-12-08T11:09:49.857Z","comments":true,"path":"2018/11/03/compositeReuse/","link":"","permalink":"http://seina.top/2018/11/03/compositeReuse/","excerpt":"","text":"","categories":[{"name":"大战设计模式","slug":"大战设计模式","permalink":"http://seina.top/categories/大战设计模式/"}],"tags":[{"name":"设计原则","slug":"设计原则","permalink":"http://seina.top/tags/设计原则/"}],"keywords":[{"name":"大战设计模式","slug":"大战设计模式","permalink":"http://seina.top/categories/大战设计模式/"}]},{"title":"常见设计原则-里氏替换原则","slug":"ridleyReplace","date":"2018-11-02T03:28:42.000Z","updated":"2018-11-14T14:35:17.146Z","comments":true,"path":"2018/11/02/ridleyReplace/","link":"","permalink":"http://seina.top/2018/11/02/ridleyReplace/","excerpt":"","text":"里氏替换原则：子类型必须能够替换掉它们的父类型。 含义1：子类可以实现父类的抽象方法，但是不可以覆盖父类的非抽象方法含义2：子类中可以增加自己特有的方法含义3：当子类的方法重写父类的方法时，方法的前置条件(即方法的输入/输出)要比父类方法的输入参数更宽松含义4：当子类的方法实现父类的方法时(重写/重载/实现抽象方法)，方法的后置条件(即方法的输出/返回值)要比父类更严格或者相等 一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类和子类对象的区别，也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化，简单地说，子类型必须能够替换掉它们的父类型。 如果面向对象设计时，一个是鸟类，一个是企鹅类，如果鸟是可以飞的，企鹅不会飞，那么企鹅是鸟吗？企鹅可以继承鸟这个类吗？显然是不可以的，子类拥有父类所有非private的行为和属性。鸟会飞，而企鹅不会飞。尽管在生物学分类上，企鹅是一种鸟，但在编程世界里，企鹅不能以父类–鸟的身份出现，因为前提是说所有鸟都能飞，企鹅不能飞，所以企鹅不能继承鸟类。 也正是因为有了里氏替换原则，使得继承复用成为可能，只有当子类可以替换掉父类，软件单位的功能不受影响时，父类才能真正地被复用，而子类也能够在父类的基础上增加新的行为。比如说猫是继承动物类的，以动物的身份拥有吃、喝、跑、叫等行为，可当某一天，我们需要狗、牛、羊也拥有类似的行为，由于它们都是继承动物，所以更改实例化的地方，程序其他处都不需要改变。需要变化的是猫更换成狗、牛、羊等别的动物，程序其他地方不需要改变。 正是由于子类型的可替换性才使得使用父类类型的模块在无需修改的情况下就可以扩展","categories":[{"name":"大战设计模式","slug":"大战设计模式","permalink":"http://seina.top/categories/大战设计模式/"}],"tags":[{"name":"设计原则","slug":"设计原则","permalink":"http://seina.top/tags/设计原则/"}],"keywords":[{"name":"大战设计模式","slug":"大战设计模式","permalink":"http://seina.top/categories/大战设计模式/"}]}]}